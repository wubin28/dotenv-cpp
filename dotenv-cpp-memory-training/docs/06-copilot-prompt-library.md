# GitHub Copilot 提示词库

本文档提供了一套完整的 GitHub Copilot 提示词模板，帮助您高效地分析和修复 C++ 内存问题。提示词按功能分类，并附带预期输出示例和使用技巧。

---

## 1. 发现问题类提示词

### 1.1 通用内存问题分析

#### 💬 提示词模板

```
请分析以下 C++ 代码的内存管理问题，列出所有潜在的内存泄露、悬挂指针和资源管理错误：

[粘贴您的代码]
```

#### 📋 预期输出示例

```
代码存在以下内存管理问题：

1. 内存泄露（第 15 行）
   - 使用 new 分配内存，但析构函数未释放
   - 建议：在析构函数中添加 delete

2. 浅拷贝问题（第 20-25 行）
   - 默认拷贝构造函数执行浅拷贝
   - 可能导致 double-free
   - 建议：实现深拷贝或禁用拷贝

3. 悬挂指针（第 30 行）
   - 返回局部变量的指针
   - 建议：返回 std::string 或使用输出参数
```

---

### 1.2 针对特定问题的提示词

#### 检查内存泄露

```
检查这段代码是否有内存泄露。如果有，请指出泄露的位置和原因：

[粘贴代码]
```

#### 检查拷贝安全性

```
这个类的拷贝构造函数安全吗？是否需要实现深拷贝？

[粘贴类定义]
```

#### 检查悬挂指针

```
这个函数返回的指针会悬挂吗？为什么？

[粘贴函数代码]
```

#### 检查异常安全

```
如果这段代码抛出异常会发生什么？资源会正确释放吗？

[粘贴代码]
```

---

### 1.3 代码审查提示词

#### 全面审查

```
作为 C++ 内存安全专家，请审查以下代码，重点关注：
1. 内存泄露
2. 悬挂指针
3. double-free
4. 异常安全
5. 违反 RAII 原则的地方

[粘贴代码]
```

#### 对比审查

```
对比以下两段代码，哪一段更安全？为什么？

代码 A：
[粘贴代码 A]

代码 B：
[粘贴代码 B]
```

---

## 2. 理解问题类提示词

### 2.1 解释概念

#### 内存泄露

```
用简单的语言解释：什么是内存泄露？为什么会发生？有什么危害？
```

#### 浅拷贝 vs 深拷贝

```
解释浅拷贝和深拷贝的区别，并举例说明在什么情况下浅拷贝会导致问题。
```

#### RAII 原则

```
什么是 RAII 原则？如何应用到这段代码？

[粘贴代码]
```

#### 未定义行为

```
什么是 C++ 的未定义行为（Undefined Behavior）？为什么使用悬挂指针是 UB？
```

---

### 2.2 分析具体代码

#### 分析生命周期

```
分析以下代码中对象和指针的生命周期，指出哪里可能出现悬挂指针：

[粘贴代码]
```

#### 分析异常路径

```
追踪这段代码的所有异常路径，指出哪些资源可能不会被释放：

[粘贴代码]
```

#### 分析内存布局

```
解释以下代码的内存布局，包括栈内存和堆内存的使用：

[粘贴代码]
```

---

### 2.3 "为什么"类提示词

```
为什么这里会导致 double-free？

[粘贴代码]
```

```
为什么 std::string 不需要手动管理内存？
```

```
为什么返回局部变量的指针是危险的？
```

```
为什么使用 delete 而不是 delete[] 会导致未定义行为？
```

---

## 3. 生成修复代码类提示词

### 3.1 修复内存泄露

```
请修复此代码的内存泄露问题，并解释修复方法：

[粘贴代码]
```

#### 📋 预期输出示例

```cpp
// 修复方法 1：正确实现析构函数
~ConfigManager() {
    delete[] env_filename_;
    env_filename_ = nullptr;
}

// 修复方法 2（更好）：使用 std::string
class ConfigManager {
    std::string env_filename_;  // 自动管理内存
    // 无需自定义析构函数
};

解释：
- 方法 1 遵循 RAII，手动释放资源
- 方法 2 使用标准库容器，避免手动管理
- 推荐方法 2，更简洁且异常安全
```

---

### 3.2 实现深拷贝

```
为这个类实现正确的拷贝构造函数和拷贝赋值操作符（深拷贝）：

[粘贴类定义]

要求：
1. 实现深拷贝
2. 处理自赋值
3. 提供异常安全保证
```

#### 📋 预期输出示例

```cpp
// 拷贝构造函数
ConfigManager(const ConfigManager& other) {
    if (other.env_filename_ != nullptr) {
        env_filename_ = new char[strlen(other.env_filename_) + 1];
        strcpy(env_filename_, other.env_filename_);
    } else {
        env_filename_ = nullptr;
    }
}

// 拷贝赋值操作符
ConfigManager& operator=(const ConfigManager& other) {
    // 检查自赋值
    if (this == &other) {
        return *this;
    }

    // 释放旧资源
    delete[] env_filename_;

    // 拷贝新资源
    if (other.env_filename_ != nullptr) {
        env_filename_ = new char[strlen(other.env_filename_) + 1];
        strcpy(env_filename_, other.env_filename_);
    } else {
        env_filename_ = nullptr;
    }

    return *this;
}
```

---

### 3.3 使用智能指针重构

```
使用 std::unique_ptr 重构这段代码，消除手动内存管理：

[粘贴代码]
```

```
将这段使用裸指针的代码改为使用 std::shared_ptr：

[粘贴代码]
```

---

### 3.4 使用 RAII 重构

```
将这段手动资源管理的代码改为使用 RAII 原则：

[粘贴代码]

要求：
1. 使用标准库容器（std::vector, std::string）
2. 确保异常安全
3. 无需手动 delete
```

---

### 3.5 修复悬挂指针

```
修复这个返回悬挂指针的问题，提供 3 种不同的解决方案：

[粘贴函数代码]
```

#### 📋 预期输出示例

```cpp
// 方案 1：返回 std::string（推荐）
std::string get_value() {
    std::string result = "...";
    return result;  // RVO 优化
}

// 方案 2：输出参数
void get_value(std::string& out) {
    out = "...";
}

// 方案 3：返回智能指针（过度设计）
std::unique_ptr<std::string> get_value() {
    return std::make_unique<std::string>("...");
}

推荐方案 1：简洁、高效（RVO）、符合现代 C++ 风格
```

---

## 4. 对比和重构类提示词

### 4.1 对比优缺点

```
对比使用裸指针和智能指针的优缺点：

场景：管理一个动态分配的对象
```

```
对比以下三种字符串管理方式的优缺点：
1. char* + new/delete
2. std::string
3. std::unique_ptr<char[]>
```

---

### 4.2 展示修复前后对比

```
展示修复前后的代码对比，并解释改进之处：

修复前：
[粘贴原始代码]
```

#### 📋 预期输出示例

```
修复前：
class ConfigManager {
    char* data_;
public:
    ConfigManager(const char* s) {
        data_ = new char[strlen(s) + 1];
        strcpy(data_, s);
    }
    ~ConfigManager() {} // ❌ 未释放
};

修复后：
class ConfigManager {
    std::string data_;  // ✅ 自动管理
public:
    ConfigManager(const std::string& s) : data_(s) {}
    // 编译器生成的析构函数已足够
};

改进：
1. 消除内存泄露
2. 无需手动管理内存
3. 异常安全
4. 拷贝语义自动正确
5. 代码更简洁
```

---

### 4.3 现代 C++ 重构

```
使用现代 C++（C++11/14/17）重构这段代码：

[粘贴旧代码]

要求：
1. 使用智能指针
2. 使用 auto 简化类型
3. 使用范围 for 循环
4. 使用 std::make_unique/std::make_shared
```

---

### 4.4 多方案对比

```
为这段代码提供 3 种不同的修复方案，并对比它们的权衡（性能、安全性、可维护性）：

[粘贴代码]
```

---

## 5. 学习和探索类提示词

### 5.1 概念解释

```
解释 std::unique_ptr 和 std::shared_ptr 的区别。何时使用哪一个？
```

```
什么时候应该使用移动语义？举例说明。
```

```
C++ 的三法则、五法则和零法则分别是什么？提供示例代码。
```

```
如何设计一个异常安全的类？列出关键原则和示例。
```

---

### 5.2 深入理解

```
std::vector 内部如何实现 RAII？它的析构函数做了什么？
```

```
C++ 编译器如何优化按值返回 std::string？什么是 RVO 和 NRVO？
```

```
什么是 copy-and-swap idiom？如何使用它实现异常安全的赋值操作符？
```

```
栈展开（Stack Unwinding）是如何工作的？为什么 RAII 能保证异常安全？
```

---

### 5.3 标准库探索

```
列出 C++ 标准库中所有遵循 RAII 原则的类，并解释它们管理的资源类型。
```

```
std::lock_guard 如何保证线程安全？展示示例代码。
```

```
std::unique_lock 和 std::lock_guard 的区别是什么？
```

---

## 6. 提示词编写技巧

### 6.1 如何编写清晰的提示词

#### ✅ 好的提示词

**具体而非笼统：**
```
❌ 不好：这段代码有问题吗？
✅ 好的：这段代码是否有内存泄露？如果有，请指出具体位置和原因。
```

**提供上下文：**
```
❌ 不好：修复这个 bug
✅ 好的：这段代码在拷贝对象时会崩溃。请分析原因并提供修复方案。
```

**明确期望的输出格式：**
```
❌ 不好：解释 RAII
✅ 好的：用简单的语言解释 RAII 原则，并提供一个实际的 C++ 代码示例。
```

---

### 6.2 如何迭代改进提示词

#### 初始提示词
```
这段代码有什么问题？

[代码]
```

#### 如果输出不够具体，追问
```
请详细解释为什么这里会导致内存泄露。
```

#### 如果需要修复方案
```
请提供修复代码，并解释为什么这样修复。
```

#### 如果需要多种方案
```
请提供 3 种不同的修复方案，并对比优缺点。
```

---

### 6.3 如何验证 Copilot 的输出

#### 步骤 1：理解输出
- 不要盲目复制代码
- 逐行理解 Copilot 的建议

#### 步骤 2：编译测试
```bash
g++ -Wall -Wextra -fsanitize=address test.cpp -o test
./test
```

#### 步骤 3：使用工具验证
```bash
./scripts/check_memory.sh
```

#### 步骤 4：追问疑问
```
为什么这里使用 std::move？有什么好处？
```

---

## 7. 常见 Copilot 错误及应对

### 7.1 错误 1：建议使用 delete 而不是 delete[]

#### 现象
```cpp
// Copilot 错误建议
~ConfigManager() {
    delete env_filename_;  // ❌ 应该是 delete[]
}
```

#### 如何追问
```
为什么应该使用 delete[] 而不是 delete 来释放 env_filename_？

env_filename_ 是这样分配的：
env_filename_ = new char[strlen(filename) + 1];
```

#### 📋 预期纠正输出
```
因为 env_filename_ 是通过 new[] 分配的数组，必须用 delete[] 释放。

new 和 delete 必须配对：
- new  <-> delete
- new[] <-> delete[]

使用错误的 delete 会导致未定义行为。
```

---

### 7.2 错误 2：赋值操作符未检查自赋值

#### 现象
```cpp
// Copilot 错误建议
ConfigManager& operator=(const ConfigManager& other) {
    delete[] data_;  // ⚠️ 未检查自赋值
    data_ = new char[strlen(other.data_) + 1];
    strcpy(data_, other.data_);
    return *this;
}
```

#### 如何追问
```
这个赋值操作符处理自赋值了吗？如果 config = config 会发生什么？
```

#### 📋 预期纠正输出
```
未处理自赋值。如果 this == &other：
1. delete[] data_：释放自己的内存
2. strcpy(data_, other.data_)：访问已释放的内存

修复：添加自赋值检查
if (this == &other) {
    return *this;
}
```

---

### 7.3 错误 3：过度设计

#### 现象
```cpp
// Copilot 过度设计的建议
class ConfigManager {
    std::shared_ptr<std::vector<std::unique_ptr<std::string>>> data_;
    // 对于简单的字符串，这太复杂了
};
```

#### 如何引导
```
给我一个最简单的修复方案，避免过度设计。

原始代码：
[粘贴简单场景]
```

#### 📋 预期简化输出
```cpp
// 简单方案
class ConfigManager {
    std::string data_;  // 足够了
};
```

---

### 7.4 错误 4：建议使用过时的 C++ 特性

#### 现象
```cpp
// Copilot 建议使用 auto_ptr（已废弃）
std::auto_ptr<int> ptr(new int);  // ❌ C++17 已移除
```

#### 如何纠正
```
auto_ptr 已被废弃。请使用现代 C++（C++11 及以上）的替代方案。
```

#### 📋 预期纠正输出
```cpp
使用 std::unique_ptr 替代 auto_ptr：
std::unique_ptr<int> ptr = std::make_unique<int>(10);

或使用 std::shared_ptr（如需共享所有权）：
std::shared_ptr<int> ptr = std::make_shared<int>(10);
```

---

## 8. 高级提示词技巧

### 8.1 上下文增强

**提供编译错误信息：**
```
我的代码无法编译，错误信息如下：

[粘贴编译器错误]

原始代码：
[粘贴代码]

请帮我修复。
```

**提供运行时错误信息：**
```
程序崩溃，AddressSanitizer 报告如下：

[粘贴 ASan 报告]

相关代码：
[粘贴代码]

请分析崩溃原因并提供修复方案。
```

---

### 8.2 角色扮演

```
你是一位资深的 C++ 代码审查专家。请审查以下代码，重点关注内存安全和性能问题：

[粘贴代码]
```

```
假设你在面试 C++ 高级工程师职位。面试官给你以下代码，要求你找出所有问题并提供改进建议：

[粘贴代码]
```

---

### 8.3 分步骤引导

```
第 1 步：分析这段代码的内存管理问题
[粘贴代码]

第 2 步：解释为什么会出现这些问题

第 3 步：提供修复方案

第 4 步：解释修复后的代码为什么是正确的
```

---

### 8.4 对比学习

```
以下是两段功能相同的代码。请对比它们的内存安全性、性能和可维护性：

版本 A（C++98）：
[粘贴旧代码]

版本 B（C++17）：
[粘贴现代代码]
```

---

## 9. 提示词模板速查表

### 快速复制使用

| 场景 | 提示词模板 |
|------|-----------|
| **发现泄露** | `检查这段代码是否有内存泄露：[代码]` |
| **检查拷贝** | `这个类的拷贝构造函数安全吗？[类定义]` |
| **检查悬挂指针** | `这个函数返回的指针会悬挂吗？[函数]` |
| **检查异常安全** | `如果抛异常会泄露吗？[代码]` |
| **修复泄露** | `请修复此代码的内存泄露：[代码]` |
| **实现深拷贝** | `为这个类实现深拷贝：[类定义]` |
| **使用智能指针** | `用 std::unique_ptr 重构：[代码]` |
| **使用 RAII** | `用 RAII 原则重构：[代码]` |
| **解释概念** | `解释 [概念]，并举例说明` |
| **对比方案** | `对比 [方案 A] 和 [方案 B] 的优缺点` |

---

## 10. 总结

### 10.1 关键要点

- ✅ **具体而非笼统**：明确指出想要检查的问题类型
- ✅ **提供上下文**：包括编译/运行错误信息
- ✅ **明确输出格式**：要求代码、解释或对比
- ✅ **迭代改进**：追问细节，直到完全理解
- ✅ **验证输出**：编译、测试、使用工具验证
- ✅ **批判性思考**：不盲目接受，理解原理

### 10.2 学习路径

1. **初学者**：使用详细的提示词模板，要求解释
2. **中级**：简化提示词,尝试自己分析
3. **高级**：只提供代码，自己发现问题，用 Copilot 验证

---

## 11. 下一步

👉 [07-best-practices.md](./07-best-practices.md) - C++ 内存管理最佳实践

👉 返回 [README.md](../README.md) - 培训总览

---

**提示：** 本提示词库会持续更新。建议您在实践中总结自己的提示词模板，并与团队分享。
