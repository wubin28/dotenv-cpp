## Me:

```
## Create your first skill

This example creates a skill that teaches Claude to explain code using visual diagrams and analogies. Since it uses default frontmatter, Claude can load it automatically when you ask how something works, or you can invoke it directly with /explain-code.

1. Create the skill directory

Create a directory for the skill in your personal skills folder. Personal skills are available across all your projects.
mkdir -p ~/.claude/skills/explain-code

2. Write SKILL.md

Every skill needs a SKILL.md file with two parts: YAML frontmatter (between --- markers) that tells Claude when to use the skill, and markdown content with instructions Claude follows when the skill is invoked. The name field becomes the /slash-command, and the description helps Claude decide when to load it automatically.
Create ~/.claude/skills/explain-code/SKILL.md:

```
---
name: explain-code
description: Explains code with visual diagrams and analogies. Use when explaining how code works, teaching about a codebase, or when the user asks "how does this work?"
---

When explaining code, always include:

1. **Start with an analogy**: Compare the code to something from everyday life
2. **Draw a diagram**: Use ASCII art to show the flow, structure, or relationships
3. **Walk through the code**: Explain step-by-step what happens
4. **Highlight a gotcha**: What's a common mistake or misconception?

Keep explanations conversational. For complex concepts, use multiple analogies.
```

3. Test the skill

You can test it two ways:
Let Claude invoke it automatically by asking something that matches the description:

```
How does this code work?
```

Or invoke it directly with the skill name:

```
/explain-code include/laserpants/dotenv/dotenv.h
```

Either way, Claude should include an analogy and ASCII diagram in its explanation.
```

## Claude code with sonnet 4.5:

```
⏺ I'll explain the code in the dotenv.h header file. Let me read it first.

⏺ Read 1 file (ctrl+o to expand)

⏺ The dotenv Library - Like a Configuration Waiter

  The Analogy

  Think of dotenv as a waiter at a restaurant who reads a menu (the .env file) and tells the
  kitchen (your program's environment) what ingredients are available. Instead of hardcoding
  "we have tomatoes and cheese" into your program, the waiter reads it from the menu each
  time and makes it available to all the chefs (functions) in your kitchen.

  The Architecture Diagram

  ┌─────────────────────────────────────────────────────────────────┐
  │                         Your Program                             │
  │  ┌────────────────────────────────────────────────────────┐    │
  │  │  int main() {                                          │    │
  │  │      dotenv::init();  ←────────────┐                  │    │
  │  │      std::getenv("DATABASE_HOST"); │                  │    │
  │  │  }                                  │                  │    │
  │  └────────────────────────────────────┼────────────────────┘    │
  └─────────────────────────────────────────┼──────────────────────┘
                                            │
                           ┌────────────────▼───────────────┐
                           │     dotenv::do_init()          │
                           │  (The Parser/Loader Engine)    │
                           └────────────────┬───────────────┘
                                            │
                      ┌─────────────────────┼─────────────────────┐
                      │                     ▼                     │
                      │   ┌──────────────────────────────┐       │
                      │   │      .env File               │       │
                      │   │  ┌────────────────────────┐  │       │
                      │   │  │ DATABASE_HOST=localhost│  │       │
                      │   │  │ API_KEY="secret123"    │  │       │
                      │   │  │ PORT=${DEFAULT_PORT}   │  │       │
                      │   │  └────────────────────────┘  │       │
                      │   └──────────────────────────────┘       │
                      │                                           │
                      │   Processing Pipeline:                   │
                      │   ┌──────────────────────────────┐       │
                      │   │ 1. Read line by line         │       │
                      │   │ 2. Trim whitespace           │       │
                      │   │ 3. Strip quotes              │       │
                      │   │ 4. Resolve variables ($VAR)  │       │
                      │   │ 5. Call setenv()             │       │
                      │   └──────────────────────────────┘       │
                      └───────────────────────────────────────────┘
                                            │
                                            ▼
                           ┌──────────────────────────────────┐
                           │   System Environment Variables    │
                           │   (Available to all processes)    │
                           └──────────────────────────────────┘

  Walking Through the Code

  The Main Entry Point (lines 125-128)

  inline void dotenv::init(const char* filename)
  {
      dotenv::do_init(OptionsNone, filename);
  }

  This is your "start here" button. When you call dotenv::init(), it defaults to reading .env
   in the current directory. It's like telling the waiter, "just bring me the regular menu."

  The Processing Engine (lines 326-370)

  The do_init() function is where the magic happens:

  1. Opens the file (line 331): file.open(filename)
  2. Reads line by line (line 337): while (getline(file, line))
  3. Skips comments and empty lines (lines 340-342): Lines starting with # or empty
  4. Splits at the equals sign (line 344): Finds KEY=value
  5. Cleans up the data:
    - Trims whitespace (line 350)
    - Strips quotes (line 351)
    - Resolves variable references like $OTHER_VAR (line 354)
  6. Sets the environment variable (line 364): Makes it available to your program

  Variable Resolution (lines 253-324)

  This is the clever part. Dotenv supports variable interpolation:

  API_URL=http://localhost:${PORT}/api

  The resolve_vars() function:
  - Searches for $VAR or ${VAR} patterns
  - Looks up those variables in the environment
  - Replaces them with their values
  - Reports errors if variables aren't defined

  Flow diagram:
  Input: "http://localhost:${PORT}/api"
           │
           ├─→ Find "${PORT}" at position 17
           ├─→ Extract "PORT"
           ├─→ Call std::getenv("PORT")
           ├─→ Replace with value: "3000"
           │
  Output: "http://localhost:3000/api"

  The Preserve Flag (line 97)

  static const unsigned char Preserve = 1 << 0;

  This is a bit flag. When you call dotenv::init(dotenv::Preserve), existing environment
  variables won't be overwritten. It's like telling the waiter, "I already ordered wine,
  don't bring me another one."

  Line 364 shows how this works:
  setenv(name.c_str(), val.c_str(), ~flags & dotenv::Preserve);

  The third parameter is overwrite. When Preserve is set, it becomes 0 (don't overwrite).

  Windows Compatibility (lines 166-182)

  Windows doesn't have setenv(), so the library provides its own implementation using
  _putenv_s(). This is like having a translator when the kitchen speaks a different language.

  The Gotcha

  Common Mistake: Forgetting that dotenv::init() must be called before accessing any
  environment variables from the .env file.

  // WRONG - variable not loaded yet!
  std::cout << std::getenv("API_KEY") << std::endl;
  dotenv::init();

  // CORRECT - load first, then use
  dotenv::init();
  std::cout << std::getenv("API_KEY") << std::endl;

  Another gotcha at include/laserpants/dotenv/dotenv.h:364: The bitwise logic ~flags &
  dotenv::Preserve is inverted. If you pass Preserve, it becomes 0 (don't overwrite). If you
  pass OptionsNone, it becomes 1 (do overwrite). This backwards logic can be confusing!

  Security Note: Never commit your .env file to version control. It's like leaving your
  restaurant's secret recipe on the front door. Add .env to your .gitignore.

✻ Worked for 37s
```
